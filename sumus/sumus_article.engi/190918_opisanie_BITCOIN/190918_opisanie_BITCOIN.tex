\documentclass[12pt,twoside,a4paper]{article}

\usepackage[utf8]{inputenc} % Включаем поддержку UTF8
\usepackage[russian]{babel} % [english, russian]

\usepackage[margin=2cm]{geometry}
\usepackage{indentfirst} % Красная строка после заголовка

\usepackage{float}

\usepackage{graphicx,xcolor} % графика для svg
\graphicspath{{fig/}}

\title{Описание работы \textbf{BITCOIN}.}
\author{engi@sumus.team}
\date{18 сентября 2019 г.}

\begin{document}

\maketitle

\section{Транзакции}

\subsection{Структура $tx$}
Структура $tx$ является носителем транзакций. $tx$ объединяет приходящие и исходящие переводы монет. При формировании $tx$ исходящие переводы будут все $UTXO$ --- \textit{непотраченные}. Структура $tx$ содержит два массива структур: $tx\_in$ и $tx\_out$.

\subsection{Структура $tx\_in$}
В структуре есть записи: $prevHash$, $prevIndex$, $scriptSig$. 

Запись $prevHash$ идентифицирует структуру $tx$ где находится $tx\_out$. 

Запись $prevIndex$ указывает на индекс массива $tx\_out[]$ для определения структуры  $tx\_out$.

Запись $scriptSig$ является первой частью подтверждающего скрипта.

\subsection{Структура $tx\_out$}
В структуре есть записи: $value$ и $scriptPubKey$. 

Запись $value$ декларирует количество монет принадлежащих данной записи. 

Запись $scriptPubKey$ является второй частью подтверждающего скрипта.

\subsection{$fee$}
Значение $fee$ вычисляется как сумма монет, полученных по $tx\_in$ $\Sigma_{in}$ минус сумма монет, полученных по $tx\_out$ $\Sigma_{out}$. Очевидно, что $\Sigma_{in}$ не может быть меньше $\Sigma_{out}$. Суммарное значение всех $fee$ по блоку является неявным источником монет для структуры $tx_0$.

\subsection{Структура $tx_0$ (\textit{coinbase})}
Структура $tx$ с индексом 0 в блоке имеет особые свойства. $tx_0$ получает монеты за закрытие блока ($reward$) и как плату за проведение транзакций ($\Sigma fee$). \textit{Не запрещено получать монеты и от $tx\_out$ источников в качестве дополнительного источника}.

$reward$ обозначен явно с особыми значениями $prevHash=0$, $prevIndex=-1$. Скрипт $scriptSig$ \textit{может быть заполнен произвольно} и может служить дополнением $nonce$. Ожидаемое количество монет за закрытие блока вычисляется по формуле в зависимости от порядкового номера блока.

$\Sigma fee$ представляет собой сумму $fee$ от остальных $tx$ структур блока. Отдельный $fee$ может быть нулевым, могут быть нулевыми все $fee$, в блоке может быть только одна $tx$ структура. В этом случае $\Sigma fee$ не добавляет монет. \textit{Конечно, для $tx_0$ $fee$ не вычисляется}.

\subsection{Формирование структуры $tx$}
Для перевода монет от одного или нескольких источников $tx\_out$ требуется подтвердить указываемые связи. Один $tx\_out$ $UTXO$ может быть связан только с одним $tx\_in$. После установления связи такой $tx\_out$ считается \textit{потраченным} и перестаёт быть $UTXO$.

Подтверждением связи будет формирование скрипта $scriptSig$ в $tx\_in$, который при конкатенации со скриптом $scriptPubKey$ из $tx\_out$ образует скрипт, дающий единственный результат $TRUE$.

Возможно написание $scriptPubKey$ такого, что к нему невозможно написать преамбулу--$scriptSig$ которая даст результат $TRUE$. Так формируется $tx\_out$, который невозможно ``потратить''.

\begin{figure}[H]
	\centering
	\def\svgwidth{16cm} % изменить размер
	\input{fig/tx__link.pdf_tex}
	\label{tx_link}
	\caption{Составление транзакции.}
\end{figure}

\subsection{Скрипты \textbf{BITCOIN}}
\textbf{BITCOIN} для подписывания переводов монет использует гибкий подход. Так называемый ``скрипт'' исполняется стековым процессором, напоминающим процессор языка $FORTH$ без ветвлений. Команды процессора содержат (кроме обычных) вычисление криптографических величин. Это позволяет использовать криптографию для подписывания переводов.

\section{Блоки $block$}
Структуры $tx$ упакованы в блоки. Последовательность блоков называется блокчейн. Формирование блока является ответственным процессом. Структуры $tx$ должны быть проверены упаковщиком блока (майнером). Майнер связывает данный блок с предыдущим блоком путём указания хеша на предыдущий блок, формирует дерево Меркла хешей структур $tx$ блока и подгоняет $nonce$ и $tx_0.tx_in.scriptSig$ так, чтобы хеш всего блока удовлетворял условию сложности. 


\subsection{Структура $block$}

Блок состоит из заголовка и массива структур $tx$:
\begin{itemize}
	\item $block\_header$ заголовок блока 80 байт
	\item $tx[]$ массив структур $tx$
\end{itemize}

Структура заголовка:
\begin{itemize}
	\item $version$ Версия типа блока
	\item $prev\_block$ Хеш предыдущего блока. \textit{Note: блок не содержит собственного хеша.}
	\item $merkle\_root$	Хеш дерева Меркла структур $tx[]$.
	\item $timestamp$ \textit{(несущественная величина)}
	\item $bits$ сложность майнинга
	\item $nonce$ подгонка хеша
	\item $tx[]$ массив структур $tx$
\end{itemize}

\subsection{Дерево Меркла (\textit{ДМ}) и \textit{SPV} (\textit{Simplified Payment Verification})}
К существенным свойствам \textit{ДМ} отнесём:
\begin{itemize}
	\item неизменяемость значений элементов \textit{ДМ}
	\item неизменяемость расположения элементов \textit{ДМ}
\end{itemize}

Если \textit{НОД} использует \textit{SPV} то ему достаточно синхронизировать только цепочку $block\_header$. В принципе, \textit{НОД} может первоначально синхронизировать блоки, но, убедившись в целостности содержимого блока, локально сохранять только $block\_header$. Для количества блоков $6*10^5$, объём хранимой информации составит $6*10^5 * 81 = 5*10^7$ или 50 МБайт. Такой объём вполне помещается на самых скромных мобильных устройствах.

Для того, чтобы продемонстрировать существование транзакции (выполнение платежа)  достаточно получить от системы или контрагента цепочку хешей по одному на каждый уровень \textit{ДМ}. Затем, посчитать хеш от проверяемой транзакции и кумулятивные хеши до получения хеша \textit{ДМ} блока. Полученный хеш должен совпасть с хешем одного из $block\_header.merkle\_root$.

Очевидна недопустимость наличия одинаковых хешей \textit{ДМ} блока в блокчейне и одинаковых хешей $tx$. 

Первое условие выполняется при выполнении второго условия. Действительно, при разных хешах $tx$, хеши \textit{ДМ} тоже будут разные.

Второе условие выполняется так: $tx\_in$ содержит записи $prevHash$ и $prevIndex$, которые не могут быть одновременно одинаковыми. Тогда бы они ссылались на одну структуру $tx\_out$, а это запрещено (двойная трата).
\section{Передача монет}

\subsection{``Адрес'' кошелька}

В регистре BITCOIN нет явно определяемого универсального адреса отправителя/получателя монет. Гибкость формирования сущности ``транзакция'' позволяет задавать несколько разных источников монет и несколько разных получателей монет. 

Разные источники монет позволяют добавлять/объединять монеты при их получении. При этом, владелец одного источника будет фактическим получателем, а владельцы других источников будут отправителями. Можно предположить, что такая транзакция ``не знает'' заранее куда она сама будет переводить монеты. Поэтому эта транзакция будет иметь один $tx\_out$.

Разные получатели монет позволяют разделить монеты при их передаче. Такая необходимость возникает при трате ``со сдачей''. При этом один получатель --- это владелец монет и получает он ``сдачу''. Остальные получатели (возможно только один получатель) --- это фактические получатели монет.

Кроме того, возможны более сложные комбинации количества, принадлежности и аутентификации участников транзакции. Также, возможно создать $tx\_out$ такой, который невозможно ``потратить''. 

Эти условия усложняют идентификацию (получение ``адреса'' кошелька) участников. 

Ничто не мешает лицу-владельцу кошелька использовать разные $scriptPubKey$ (с разными фактическими публичными ключами). Такая стратегия потребует лишь увеличения персонального хранилища приватных ключей и более сложного процесса выполнения транзакций. Можно хранить только ключи, связанные с непотраченными $tx\_out$.

\quotation{При совершении очередной операции с ВТС чаще всего создается новый адрес \dots}\footnote{https://ru.bitcoinwiki.org/wiki/Адрес [Для чего нужен биткоин адрес]}

Постоянный ``адрес'' кошелька может потребоваться, например, для автоматизированного интернет-магазина, когда получатель монет не согласовывается при каждом индивидуальном переводе.

Также, постоянный ``адрес'' кошелька удобен при использовании приложения для индивидуального применения.

\subsection{Идентификация участников транзакции}

$tx\_in$ помогает определить источники монет. Эта запись указывает на $tx\_out$ предшествующей транзакции.

$tx\_out$ содержит $scriptPubKey$, \textit{при анализе которого можно получить} (не всегда) публичный ключ $pubKey$, который идентифицирует владельца монет.

Итак, в момент существования транзакции:
\begin{itemize}
	\item $pubKey$, указанный в записи $tx\_out$ идентифицирует владельца монет
	\item $pubKey$, указанный в записи $tx\_out$ на которую ссылается $tx\_in$ идентифицирует отправителя монет
\end{itemize}

\end{document}
